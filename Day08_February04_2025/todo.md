# TODO

Tasks for Day08

# Algorithms and Complexity Topics


## Sorting Algorithms

- [ ] **Sorting Algorithms**
  - [ ] *Comparison-based Sorting*
    - [ ] **Bubble Sort**  
      Understand its mechanism and worst-case complexity.
    - [ ] **Selection Sort**  
      Examine how it selects the minimum/maximum element repeatedly.
    - [ ] **Insertion Sort**  
      Explore its performance on nearly sorted data.
    - [ ] **Merge Sort**  
      Learn the divide and conquer approach and how recursion is used.
    - [ ] **Quick Sort**  
      Investigate pivot selection and average vs. worst-case performance.
    - [ ] **Heap Sort**  
      Understand how the heap data structure is used for sorting.
  - [ ] *Non-comparison-based Sorting*
    - [ ] **Counting Sort**  
      Analyze when counting sort is efficient and its space requirements.
    - [ ] **Radix Sort**  
      Explore how it sorts numbers digit by digit.
    - [ ] **Bucket Sort**  
      Learn about distribution and its effectiveness on uniformly distributed data.
  - [ ] *Hybrid Sorting Algorithms*
    - [ ] **Tim Sort**  
      Understand how it combines insertion sort and merge sort.
    - [ ] **Intro Sort**  
      Study how it starts with quick sort and switches to heap sort to guarantee worst-case performance.

---

## Searching Algorithms

- [ ] **Searching Algorithms**
  - [ ] *Basic Searching Techniques*
    - [ ] **Linear Search**  
      Explore its simplicity and scenarios where it is used.
    - [ ] **Binary Search**  
      Examine the precondition of sorted data and logarithmic complexity.
  - [ ] *Advanced Searching Methods*
    - [ ] **Interpolation Search**  
      Learn how it improves binary search on uniformly distributed data.
    - [ ] **Exponential Search**  
      Study its use in unbounded or infinite lists.
    - [ ] **Fibonacci Search**  
      Compare it with binary search and see where Fibonacci numbers come into play.
  - [ ] *Graph Search Algorithms*
    - [ ] **Depth-First Search (DFS)**  
      Understand its recursive nature and applications (e.g., maze solving).
    - [ ] **Breadth-First Search (BFS)**  
      Learn about its use in finding the shortest path in unweighted graphs.

---

## Recursion Basics

- [ ] **Recursion Basics**
  - [ ] *Fundamental Concepts*
    - [ ] **Understanding Recursion**  
      Define recursion, including the **base case** and **recursive case**.
    - [ ] **Recursion Trees and Visualization**  
      Learn how to visualize recursive calls to understand time complexity.
  - [ ] *Common Recursive Algorithms*
    - [ ] **Factorial Calculation**  
      A classic example to illustrate recursion.
    - [ ] **Fibonacci Sequence Computation**  
      Compare na√Øve recursive methods with optimized (memoized) solutions.
    - [ ] **Tower of Hanoi**  
      Explore recursion with a puzzle that requires moving disks.
    - [ ] **Recursive Sorting**  
      Look at how recursion is implemented in algorithms like merge sort and quick sort.
  - [ ] *Analyzing Recursion*
    - [ ] **Recurrence Relations**  
      Formulate recurrence relations for recursive algorithms.
    - [ ] **Solving Recurrences**  
      Use methods like the **Master Theorem** to determine time complexity.

---

## Additional Related Concepts

- [ ] **Additional Related Concepts**
  - [ ] **Complexity Analysis**
    - [ ] **Big O, Big Theta, and Big Omega Notation**  
      Learn how these notations describe upper, tight, and lower bounds.
    - [ ] **Time Complexity**  
      Analyze how algorithm performance scales with input size.
    - [ ] **Space Complexity**  
      Understand the memory requirements of algorithms.
    - [ ] **Best-case, Worst-case, and Average-case Analysis**  
      Compare different scenarios and their impacts on performance.
  - [ ] **Algorithm Design Paradigms**
    - [ ] **Divide and Conquer**  
      Study how problems are broken down into smaller subproblems.
    - [ ] **Dynamic Programming**  
      Learn about optimizing recursive algorithms with memoization.
    - [ ] **Greedy Algorithms**  
      Understand how making locally optimal choices can lead to a global optimum.
    - [ ] **Backtracking**  
      Explore methods for solving problems incrementally and undoing choices.
    - [ ] **Branch and Bound**  
      Learn techniques for solving optimization problems by pruning the search space.
  - [ ] **Data Structures Impacting Algorithms**
    - [ ] **Arrays and Linked Lists**  
      Review how these structures affect sorting and searching.
    - [ ] **Stacks and Queues**  
      Understand their role in recursion (e.g., function call stack) and graph traversals.
    - [ ] **Trees and Graphs**  
      Examine their impact on algorithm design and complexity.
    - [ ] **Hash Tables**  
      Explore how hashing provides efficient lookup times.